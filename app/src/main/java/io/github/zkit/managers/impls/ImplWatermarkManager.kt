package io.github.zkit.managers.impls

import android.content.Context
import android.view.View
import android.view.ViewGroup
import io.github.zkit.beans.BeanWatermarkConfig
import io.github.zkit.managers.IWatermarkManager
import io.github.zkit.managers.impls.lua.LuaLibAndroid
import io.github.zkit.managers.impls.lua.LuaLibJava
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.koin.core.component.KoinComponent
import org.luaj.vm2.Globals
import org.luaj.vm2.LuaTable
import org.luaj.vm2.LuaValue
import org.luaj.vm2.lib.DebugLib
import org.luaj.vm2.lib.PackageLib
import org.luaj.vm2.lib.jse.CoerceJavaToLua
import org.luaj.vm2.lib.jse.JsePlatform
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.io.File
import java.util.Properties

internal class ImplWatermarkManager : IWatermarkManager, KoinComponent {

    companion object {
        private const val MAIN_LUA = "main.lua"
        private const val PROJECT_CONFIG = "config.properties"
        private const val PROJECT_PATH = "PROJECT_PATH"
    }

    private val mLogger: Logger = LoggerFactory.getLogger(this.javaClass)
    private val mConfigMap: HashMap<String, BeanWatermarkConfig> = HashMap()

    private var mLuaEngine: Globals = JsePlatform.standardGlobals()

    override val config: HashMap<String, BeanWatermarkConfig>
        get() = mConfigMap

    override suspend fun load(path: File) {
        val mainLuaFile = File(path, MAIN_LUA)
        PackageLib.DEFAULT_LUA_PATH = path.absolutePath.plus(other = "/?.lua")

        mLuaEngine = JsePlatform.standardGlobals()

        mLuaEngine.set(PROJECT_PATH, path.absolutePath)

        mLuaEngine.load(LuaLibAndroid())
        mLuaEngine.load(DebugLib())
        mLuaEngine.load(LuaLibJava())

        mLuaEngine.load(mainLuaFile.reader().readText()).call()

        loadConfig()
        mergeConfig()
    }

    override suspend fun layout(context: Context): ViewGroup = withContext(context = Dispatchers.Main) {
        val configsLuaTable = LuaTable()
        for (mutableEntry: MutableMap.MutableEntry<String, BeanWatermarkConfig> in mConfigMap) {
            val itemLuaTable = LuaTable()
            itemLuaTable["value"] = LuaValue.valueOf(mutableEntry.value.value)
            itemLuaTable["visibility"] = LuaValue.valueOf(mutableEntry.value.visibility)
            configsLuaTable[mutableEntry.key] = itemLuaTable
        }
        return@withContext mLuaEngine["layout"].call(CoerceJavaToLua.coerce(context), configsLuaTable).checkuserdata() as ViewGroup
    }


    override suspend fun save() = withContext(context = Dispatchers.IO) {
        val configFile: File = configFile
        val properties = Properties()
        if (configFile.exists().not()) {
            configFile.createNewFile()
        }
        for (mutableEntry: MutableMap.MutableEntry<String, BeanWatermarkConfig> in mConfigMap) {
            properties.setProperty(mutableEntry.key + ".visibility", mutableEntry.value.visibility.toString())
            if (mutableEntry.value.value.isBlank().not()) {
                properties.setProperty(mutableEntry.key + ".value", mutableEntry.value.value)
            }
        }
        properties.store(configFile.writer(), "Auto generated by zkit")
    }

    private val configFile: File
        get() = File(mLuaEngine[PROJECT_PATH].checkjstring(), PROJECT_CONFIG)


    private suspend fun loadConfig() = withContext(context = Dispatchers.IO) {
        mConfigMap.clear()
        if (mLuaEngine.get("config").isnil()) {
            return@withContext
        }
        val luaTable: LuaTable = mLuaEngine["config"].call().checktable()
        for (key: LuaValue in luaTable.keys()) {
            val keyName: String = key.checkjstring()
            val luaTableItem: LuaTable = luaTable[key].checktable()
            mConfigMap[keyName] = BeanWatermarkConfig.new(luaTableItem)
        }
    }

    private suspend fun mergeConfig() = withContext(context = Dispatchers.IO) {
        val configFile: File = configFile
        if (configFile.exists().not()) {
            return@withContext
        }

        val properties = Properties()
        properties.load(configFile.reader())
        for (mutableEntry: MutableMap.MutableEntry<String, BeanWatermarkConfig> in mConfigMap) {
            val value: String? = properties.getProperty(mutableEntry.key + ".value")
            mutableEntry.value.value = if (value?.isNotBlank() == true) value else mutableEntry.value.default
            val visibility: String? = properties.getProperty(mutableEntry.key + ".visibility")
            if (visibility?.isNotBlank() == true) {
                mutableEntry.value.visibility = visibility.toIntOrNull() ?: View.VISIBLE
            }
        }
    }

}